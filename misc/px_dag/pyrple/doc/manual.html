<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd" >

<html xmlns="http://www.w3.org/1999/xhtml" 
   xml:lang="en" >
<head>
<title>Document Title</title>
<style type="text/css">
<!-- 
body { 
   font-family: Verdana; 
   margin: 1.7em; 
}
p { font-size: 0.9em; }
pre { 
   font-size: 1em; 
   margin: 0em 3em; 
   border: 1px dashed #0c3; 
   padding: 1em; 
   color: #033; 
}
-->
</style>
</head>
<body>
<h1>Main Heading</h1>

<h2>Node()</h2>
<p>Nodes are the smallest atomic parts of an RDF system. They come in 
four different flavours: URI, bNode, Literal, and Var. Each of these are 
implemented as sub classes of Node. The Node class will always return one 
of its four sub classes upon instantiation, and <em>never</em> just a node.</p>

<p>For example:-</p>

<pre>
>>> from rdf import Node
>>> n = Node('&lt;http://www.w3.org/>')
>>> n
&lt;http://www.w3.org/>
>>> type(n)
&lt;class 'rdf.URI'>
>>> isinstance(n, Node)
True
>>> 
</pre>

<p>A Node will always have lang, dtype, string, and value properties.</p>

<pre>
>>> n.lang, n.dtype, n.string, n.value
(None, None, 'http://www.w3.org/', 'http://www.w3.org/')
>>> 
</pre>

<p>Node must be passed a single N-Triples encoded term; its sub classes 
take unencoded terms.</p>

<pre>
>>> from rdf import Node, URI
>>> URI('http://www.w3.org/')
&lt;http://www.w3.org/>
>>> Node('&lt;http://www.w3.org/>') == URI('http://www.w3.org/')
True
>>> 
</pre>

<p>Here's an example of what each of the sub classes of Node produce:-</p>

<pre>
>>> URI('http://www.w3.org/')
&lt;http://www.w3.org/>
>>> bNode('blargh')
_:blargh
>>> Var('blargh')
?blargh
>>> Literal('blargh')
"blargh"
>>> 
</pre>

<p>Note again that they produce literals which are valid N-Triples terms, 
except for Var, which is an extension borrowed from N3 and RDQL for the 
purposes of querying.</p>

<h2>Triple()</h2>
<p>A triple is simply an immutable ordered list of three Node instances. 
It is derived from tuple. Example:-</p>

<pre>
>>> from rdf import Node, Triple
>>> subj = Node('&lt;http://example.org/>')
>>> pred = Node('&lt;http://ns.example.org/#title>')
>>> objt = Node('"Example Dot Org"')
>>> Triple(subj, pred, objt)
(&lt;http://example.org/>, &lt;http://ns.example.org/#title>, "Example Dot Org")
>>> 
</pre>

<p>Passing anything which isn't a Node will raise an error. Passing anything 
other than 3 arguments will raise an error.</p>

<pre>
>>> Triple('x', 'y', 'z')

Traceback (most recent call last):
  [...]
AssertionError
>>> Triple(subj)

Traceback (most recent call last):
  [...]
NonTripleError: Not a triple: <http://example.org/>
>>> 
</pre>

<p>There's a single exception: Triple will happily take three Nodes in a 
list or tuple as a single argument.</p>

<pre>
>>> Triple([subj, pred, objt])
(&lt;http://example.org/>, &lt;http://ns.example.org/#title>, "Example Dot Org")
>>> 
</pre>

<p>It's helpful like that.</p>

<h2>Graph()</h2>
<p>Graph corresponds to the graph concept in RDF, i.e. a collection of 
triples. In other RDF APIs, Graphs are also known as stores, formulae, 
contexts, worlds, lists, etc.</p>

<p>Graphs can be created with no args.</p>

<pre>
>>> from rdf import Graph
>>> Graph()
[]
>>> 
</pre>

<p>Graph is derived from list, hence the representation. Creating an 
empty Graph as above is not very interesting, so we can get it to parse 
some N-Triples by passing them using an ntriples keyword arg.</p>

<pre>
>>> Graph(ntriples='_:p &lt;q:r> "s" .')
[(_:p, <q:r>, "s")]
>>> 
</pre>

<p>Graphs can be merged simply by adding them.</p>

<pre>
>>> F = Graph(ntriples='_:x _:y "z" .')
>>> G = Graph(ntriples='_:p &lt;q:r> "s" .')
>>> H = F + G
>>> len(H)
2
>>> 
</pre>

<p>Note that bNode and Var labels are renamed in all merges to prevent 
collisions.</p>

<pre>
>>> H
[(_:p, &lt;q:r>, "s"), (_:id176100372x, _:id176100372y, "z")]
</pre>

<p>The scary-looking ids are to prevent merge collisions. The hash of the 
graph being merged is used. Since Graphs have hashes, it means that they 
can be compared; this is graph isomorphism testing.</p>

<pre>
>>> G.hash()
182181844
>>> F == G
False
>>> 
</pre>

<h2>Example Application</h2>

<pre>
[ rdf:type :Major, :Project; 
  :date "2003-05"; 
  :name "The Splunge Project"; 
  :homepage &lt;http://example.org/splunge> ] .

[ rdf:type :Major, :Project; 
  :date "2003-05"; 
  :name "Project Plimpy"; 
  :homepage &lt;http://example.org/plimpy> ] .

[ rdf:type :Minor, :Project; 
  :date "2003-05"; 
  :name "The Flimble Project"; 
  :homepage &lt;http://example.org/flimble> ] .
</pre>

<p>To print...</p>

<pre>
G = Graph(uri="projects.rdf")

li = '&lt;li>&lt;a href="{%s}">{%s}&lt;/a>&lt;/li>'
print '&lt;h2>Major Projects&lt;/h2>'
print '&lt;ul>'
for project in G.getPath("*/rdf:type/:Major", sortBy="*/:date"): 
   project.print(G, li % ("*/:homepage/*", "*/:name/*"))
print '&lt;/ul>'

print '&lt;h2>Minor Projects&lt;/h2>'
print '&lt;ul>'
for project in G.getPath("*/rdf:type/:Minor", sortBy="*/:date"): 
   project.print(G, li % ("*/:homepage/*", "*/:name/*"))
print '&lt;/ul>'
</pre>

</body>
</html>