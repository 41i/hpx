[/=============================================================================
Copyright (C) 2012 Adrian Serio
Copyright (C) 2012 Vinay C Amatya

Distributed under the Boost Software License, Version 1.0. (See accompanying
file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]

[section:examples Examples]

The following sections of our tutorial analyzes some examples to help you get
familiar with the HPX style of programming. We start off with simple examples
that utilize basic HPX elements and then begin to expose the reader to the more
complex, yet powerful, HPX concepts.

[/Proofread by:]
[/Adrian Serio 3-13-12]
[/Phillip LeBlanc 3-13-12]

[/////////////////////////////////////////////////////////////////////////////]
[section:fibonacci Fibonacci]

The Fibonacci sequence is a sequence of numbers starting with 0 and 1 where
every subsequent number is the sum of the previous two numbers. In this
example, we will use HPX to calculate the value of the n-th element of the
Fibonacci sequence. In order to compute this problem in parallel, we will use
a facility known as a Future.

As shown in the [link examples.future_schematics figure] below, a Future
encapsulates a delayed computation. It acts as
a proxy for a result initially not known, most of the time because the
computation of the result has not completed yet. The Future synchronizes the
access of this value by optionally suspending any HPX-threads requesting the
result until the value is available. When a Future is created, it spawns a
new HPX-thread (either remotely with a parcel or locally by placing it into
the thread queue) which, when run, will execute the action associated with
the Future. The arguments of the action are bound when the Future is created.

[fig future_schematics.png..Schematic of a Future execution..examples.future_schematics]

Once the action has finished executing, a write operation is performed on the
Future. The write operation marks the Future as completed, and optionally
stores data returned by the action. When the result of the delayed computation
is needed, a read operation is performed on the Future. If the Future's action
hasn't completed when a read operation is performed on it, the reader
HPX-thread is suspended until the Future is ready. The Future facility allows
HPX to schedule work early in a program so that when the function value is
needed it will already be calculated and available. We use this property in our
Fibonacci example below to enable its parallel execution.

[heading Setup]

[teletype]

The source code for this example can be found [hpx_link examples/quickstart/fibonacci.cpp..here]. 

To compile this program, go to your HPX build directory (see [link hpx.tutorial.getting_started Getting
Started] for information on configuring and building HPX) and enter:

``
    $ make examples.quickstart.fibonacci
``

[/ If you are using Visual Studio, simply build the target called "fibonacci". It
will be under "Quickstart" in "Examples". ]

To run the program type:

``
    $ ./bin/fibonacci
``

[/or in Visual Studio, right click on the target and select "Debug -> Start new instance". ]

This should print (time should be approximate):

``
    fibonacci(10) == 55
    elapsed time: 0.00186288 [s]
``

This run used the default settings, which calculate the tenth element of the
Fibonacci sequence. To declare which Fibonacci value you want to calculate, use
the [^--n-value] option. Additionally you can use the
[hpx_cmdline [^--hpx:threads]] option to declare how many OS-threads you
wish to use when running the program. For instance, running:

``
    $ ./bin/fibonacci --n-value 20 --hpx:threads 5
``

Will yield:

``
    fibonacci(20) == 6765
    elapsed time: 0.233827 [s]
``

[c++]

[fixme How do we set command line options on Windows?]

[heading Walkthrough]

[c++]

Now that you have compiled and run the code, lets look at how the code works.
Since this code is written in C++, we will begin with the `main` function.
Here you can see that in HPX, `main` is only used to initialize the runtime
system. It is important to note that application-specific command line options
are defined here. HPX uses
[@http://www.boost.org/doc/libs/1_49_0/doc/html/program_options.html Boost.Program Options]
for command line processing. You can see that our programs [^--n-value] option
is set by calling the `add_options()` method on an instance of
`boost::program_options::options_description`.  The default value of the
variable is set to 10. This is why when we ran the program for the first time
without using the [^--n-value] option the program returned the 10th value of
the Fibonacci sequence. The constructor argument of the description is the text
that appears when a user uses the [^--help] option to see what command line
options are available. `HPX_APPLICATION_STRING` is a macro that expands to a
string constant containing the name of the HPX application currently being
compiled.

[import ../examples/quickstart/fibonacci.cpp]
[fib_main]

The `hpx::init()` function in `main` starts the runtime system, and invokes
`hpx_main()` as the first HPX-thread. Below we can see that the basic program
is simple. The command line option `--n-value` is read in, a timer
(`hpx::util::high_resolution_timer`) is set up to record the time it takes to
do the computation, an `hpx::lcos::future<>` is created, the `get()` function 
on the `hpx::lcos::future<>` is called to retrieve or wait for the result, and
the answer is printed out.

[fib_hpx_main]

Upon a closer look we see that the `hpx::lcos::future<>` we created is assigned
the return of `hpx::lcos::async<fibonacci_action>(hpx::find_here(), n)`.
`hpx::lcos::async<>()` takes an action, in this case `fibonacci_action`, and
asynchronously kicks of the computation of the action, returning a future which
represents the result of the computation. But wait, what is an action? And what
is this `fibonacci_action`? For starters, an action is a wrapper for a
function. By wrapping functions, HPX can send packets of work to different
processing units. These vehicles allow users to calculate work now, later, or
on certain nodes. The first argument to `hpx::lcos::async<>()` is the location
where the action should be run. In this case, we just want to run the action on
the machine that we are currently on, so we use `hpx::find_here()`. To further
understand this we turn to the code to find where `fibonacci_action` was
defined:

[fib_action]

In this block of code the function `fibonacci()` is declared. After the
declaration, the function is wrapped in a `hpx::actions::plain_result_action1<>`.
A plain action is the most basic form of action. Plain actions wrap simple global
functions which are not associated with any particular object (we will discuss
other types of actions in the __accumulator_example__). The name of the action
is tells us about the arity and nature of the functions return type. `1` signifies that the
action takes 1 argument, and `result` indicates that the action returns a non-`void`
value. 

This picture should now start making sense. The function `fibonacci()` is
wrapped in an action `hpx::actions::plain_result_action1<>`, which was spawned
by `hpx::lcos::async<>()`, which returns a future. Now, lets look at the
function `fibonacci()`:

[fib_func]

On first inspection this block of code is straightforward. First, `if (n < 2)`,
meaning n is 0 or 1, then we return 0 or 1 (recall the first element
of the Fibonacci sequence is 0 and the second is 1). If n is larger than 1, then
we spawn two futures, `n1` and `n2`. Each of these futures represents an asynchronous,
recursive call to `fibonacci()`. After we've created both futures, we wait for both
of them to finish computing, and then we add them together, and return that value
as our result. The recursive call tree will continue until n is equal to 0 or 1,
at which point the value can be returned because it is implicitly known. 
When this termination condition is reached, the futures can then be added up,
producing the n-th value of the Fibonacci sequence.

[endsect] [/Fibonacci]

[/Proofread by:]
[/Adrian Serio 3-13-12]
[/Phillip LeBlanc 3-13-12]

[/////////////////////////////////////////////////////////////////////////////]
[section:hello_world Hello World]

[teletype]

This program will print out a hello world message on every OS-thread on every
locality. The output will look something like this:

``
    hello world from OS-thread 1 on locality 0
    hello world from OS-thread 1 on locality 1
    hello world from OS-thread 0 on locality 0
    hello world from OS-thread 0 on locality 1
``

[heading Setup]

The source code for this example can be found [hpx_link examples/quickstart/hello_world.cpp..here]. 

To compile this program, go to your HPX build directory (see [link hpx.tutorial.getting_started Getting
Started] for information on configuring and building HPX) and enter:

``
    $ make examples.quickstart.hello_world
``

[/ If you are using Visual Studio, simply build the target called "hello_world". It
will be under "Quickstart" in "Examples". ]

To run the program type:

``
    $ ./bin/hello_world
``

[/ or in Visual Studio, right click on the target and select "Debug -> Start new instance". ] 

This should print:

``
    hello world from OS-thread 0 on locality 0
``

To use more OS-threads use the command line option [hpx_cmdline [^--hpx:threads]]
and type the number of threads that you wish to use. For example, typing:

``
    $ ./bin/hello_world --hpx:threads 2
``

will yield:

``
    hello world from OS-thread 1 on locality 0
    hello world from OS-thread 0 on locality 0
``

[fixme How do we set command line options on Windows?]

Notice how the ordering of the two print statements will change with
subsequent runs. To run this program on multiple localities please see the
__pbs__ documentation.

[heading Walkthrough]

[c++]

Now that you have compiled and run the code, lets look at how the code works,
beginning with `main()` and `hpx_main()`:

[import ../examples/quickstart/hello_world.cpp]
[hello_world_main]
[hello_world_hpx_main]

In this excerpt of the code we again see the use of futures. This time
the futures are stored in a vector so that they can easily be accessed.
`hpx::lcos::wait()` is a family of functions that wait on for an `std::vector<>`
of futures to become ready. In this piece of code, we are using the synchronous
version of `hpx::lcos::wait()`, which takes one argument (the `std::vector<>` of
futures to wait on). This function will not return until all the futures in the
vector have been executed.

In the __fibonacci_example__, we used `hpx::find_here()` to specified the target'
of our actions. Here, we instead use `hpx::find_all_localities()`, which returns
an `std::vector<>` containing the identifiers of all the machines in the system,
including the one that we are on. 

As in the __fibonacci_example__ our futures are set using `hpx::lcos::async<>()`.
The `hello_world_foreman_action` is declared here:

[hello_world_action_wrapper]

Another way of thinking about this wrapping technique is as follows: functions
(the work to be done) are wrapped in actions, and actions can be executed
locally or remotely (e.g. on another machine participating in the computation).

Now it is time to look at the `hello_world_foreman()` function which was wrapped in
the action above: 

[hello_world_foreman]

Now, before we discuss `hello_world_foreman()`, let's talk about the
`hpx::lcos::wait()` function. `hpx::lcos::wait()` provides a way to make sure
that all of the futures have finished being calculated without having to call
`get()` for each one. The version of `hpx::lcos::wait()` used here performs an
non-blocking wait, which acts on an `std::vector<>`. It queries the state of
the futures, waiting for them to finish. Whenever a future becomes marked as
ready, `hpx::lcos::wait()` invokes a callback function provided by the user,
supplying the callback function with the index of the future in the
`std::vector<>` and the result of the future.

In `hello_world_foreman()`, an `std::set<>` called `attendance` keeps track of
which OS-threads have printed out the hello world message. When the OS-thread
prints out the statement, the future is marked as ready, and
`hpx::lcos::wait()` invokes the callback function, in this case a C+11 lambda.
This lambda erases the OS-threads id from the set `attendance`, thus letting
`hello_world_foreman()` know which OS-threads still need to print out hello
world. However, if the future returns a value of -1, the future executed on an
OS-thread which has already printed out hello world. In this case, we have to
try again by rescheduling the future in the next round. We do this by leaving
the OS-thread id in `attendance`.

Finally, let us look at `hello_world_worker()`. Here, `hello_world_worker()`
checks to see if it is on the target OS-thread. If it is executing on the
correct OS-thread, it prints out the hello world message and returns the
OS-thread id to `hpx::lcos::wait()` in `hello_world_foreman()`. If it is
not executing on the correct OS-thread, it returns a value of -1, which causes
`hello_world_foreman()` to leave the OS-thread id in `attendance`.

[hello_world_worker]

Because HPX features work stealing task schedulers, there is no way to guarantee
that an action will be scheduled on a particular OS-thread. This is why we must
use a guess-and-check approach. 

[endsect] [/Hello World]

[/Proofread by:]
[/Adrian Serio 3-13-12]
[/Phillip LeBlanc 3-13-12]

[/////////////////////////////////////////////////////////////////////////////]
[section:accumulator Accumulator]

[teletype]

Accumulator is a simple example that demonstrates a more complex HPX
programming construct: components. Components are C++ classes that expose
methods as a type of HPX actions called component actions. Components are
globally named, meaning that a component action can be called remotely (e.g.
from another machine).

In the __fibonacci_example__ and the
__hello_world_example__, we introduced plain actions, which wrapped global
functions.  The target of a plain action is an identifier which refers to a
particular machine involved in the computation. For plain actions, the target
is the machine where the action will be executed. 

Component actions, however, do not target machines. Instead, they target
component instances. The instance may live on the machine that we've invoked
the component action from, or it may live on another machine. 

The component in this example exposes four different functions:
`init()`, `add()`, `query()` and `print()`. This example creates an instance
of the accumulator, and then allows the user to enter commands at a prompt,
which subsequently invoke actions on the accumulator instance.

[heading Setup]

From your build directory, type the following:

``
    $ make examples.accumulator.accumulator
``

[heading Run the example]

From your bin directory inside install path, type the following:

On a single machine, first console:

``
    ./accumulator_client -0 -l2
``

Same machine, second console, on identical path as above:

``
    ./accumulator_client -1 -l2
``

[heading Results]

Console 1:

``
    accumulator client, you may enter some commands (try 'help' if in doubt...)
    add 5
    print
    query
    {0000000200ff0001, 000000000002ffff}> 5
    print
    add 5
    print
    query
    {0000000200ff0001, 000000000002ffff}> 10
    quit
``

Console 2:

``
    {0000000200000000, 00007fff21db4860}> 5
    {0000000200000000, 00007fff21db4860}> 5
    {0000000200000000, 00007fff21db4860}> 10
``

[heading Dissecting the Accumulator Example]

[c++]

The following text/code snippets gives us a basic infrastructure know how for
creating our own components, using the accumulator components as an example.

The file where the accumulator component object with its data and
function members are defined:

examples/accumulator/accumulator/server/accumulator.hpp

[import ../examples/accumulator/accumulator/server/accumulator.hpp]
[accumulator_namespace]
The component object class inherits properties from
`components::detail::managed_component_base<>`,
making it a managed component.

[accumulator_enum_action]
The above enumeration is for all the actions exposed by the component. Its use
comes later when we define the action as hpx action type.

[accumulator_init]
The above code snippet is a normal definition of an action that is performed by
the component, where the component is instantiated. In this case, this action
simply initializes component member variable arg_ to 0.

[accumulator_action_init]
The above code snippet encapsulates the exposed function (`accumulator::init`),
along with its component type, return type and argument types into hpx action
type, which enables boilerplate code for threads, serialization, etc. to be
generated. Here the action takes no argument and returns no value.

[accumulator_action_add]
In the above hpx action type definition, the designated action takes one argument,
and returns no value.

[accumulator_action_declare]
Here we declare all the action types that the component exposes to the hpx so
that hpx runtime system recognizes that action as a valid hpx component action.

Now we create client side methods to access the actions the component provides.
The convention followed by the accumulator example, in hpx, is to create
the following file:

example/accumulator/accumulator/stubs/accumulator.hpp

[import ../examples/accumulator/accumulator/stubs/accumulator.hpp]

[accumulator_stub]

The access methods provided at the client side allows access to component
actions available in any of the localities where the component is instantiated
as each method takes gid as first argument.

[accumulator_stub_init]
The above code snippet allows the client side to invoke init action
(`server::accumulator::init_action`) directly at the component location. This action does
not take any value as the definition of the action at the server-side implicitly
initialized the data member of accumulator component to 0.

[accumulator_stub_add]
In the above add action, we can see, the action takes an additional parameter
that is passed to the component where the component identified by gid is
instantiated. Gid is however not an argument to the action of the component.

[accumulator_stub_query]
The above code snippet gives us an action that returns a value. The return type
is unsigned long. The caller of this function needs to call `future.get()` on the
return value of the function to obtain the result returned by the function.

For example:

``
    lcos::future<unsigned long> ret_value = query_async(gid);
    ret_value.get()
``

would get the value result returned by `query_async(gid)`.

Now the following example gives another method of client side access to the
component actions. File:

examples/accumulator/accumulator/accumulator.hpp

[import ../examples/accumulator/accumulator/accumulator.hpp]

[accumulator_client]
The methods defined in the above file gives us access to actions of component in
the locality where the client object is instantiated. Here explicit gid of the
component is not passed into the function. The function takes the gid of the
locality where the client object is instantiated (`gid_`).

[accumulator_client_base]
The above code snippet make the client object instantiated effectively also inherit
properties from the `stubs::accumulator` class.

[accumulator_client_init]
The above code would call the component init action using `gid_` of the client
locality where the component is also instantiated.

Registering Actions with HPX:

/examples/accumulator/accumulator/accumulator.cpp

[import ../examples/accumulator/accumulator/accumulator.cpp]
[accumulator_cpp]

In the above file, we register component and actions with HPX. What is listed in
the `server/accumulator.hpp` file is the declaration version of the above hpx
action registration macro.


Now for instantiating the accumulator example with its component objects and
client side objects, the following file is used:

/examples/accumulator/accumulator_client.cpp

[import ../examples/accumulator/accumulator_client.cpp]
[accumulator_accumulator_client]

[accumulator_hpx_init]
The above code bootstraps the hpx runtime system.

[accumulator_hpx_main]
The above method would be entry point for accumulator application.

[accumulator_comp]
The above code returns the component type of accumulator (to distinguish accumulator
component from other component types).

[accumulator_hpx_loc]
In the above code all the available localities the hpx runtime system can access
and which support the accumulator component type are listed.

[accumulator_hpx_loc_1]
In the above code if there are more than one localities available to the runtime
system, then the first one is selected of the listed localities else the locality
where the `hpx_main()` is instantiated is selected where the accumulator component
will be instantiated.

[accumulator_create]
With the above code, the accumulator component is created locally.

[accumulator_execute]
In above code snippet, commands to execute respective actions on the accumulator
is passed.

[accumulator_hpx_finalize]
Finally the above method will initiate shutdown procedure on the hpx runtime
system.

[endsect] [/Accumulator]

[/Proofread by:]
[/Phillip LeBlanc 3-13-12]

[/////////////////////////////////////////////////////////////////////////////]

[endsect] [/Examples]

