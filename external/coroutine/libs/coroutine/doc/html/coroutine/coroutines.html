<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title> Coroutines</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.66.1">
<link rel="start" href="../index.html" title="Chapter 1. Boost.Coroutine">
<link rel="up" href="tutorial.html" title=" Tutorial">
<link rel="prev" href="stackful.html" title=" Stackful generators: Same fringe problem">
<link rel="next" href="multitasking.html" title=" Multitasking">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.htm">Home</a></td>
<td align="center"><a href="../libraries.html">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/people/people.htm">People</a></td>
<td align="center"><a href="http://www.boost.org/more/faq.htm">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="stackful.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="tutorial.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="multitasking.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="coroutine.coroutines"></a> Coroutines</h3></div></div></div>
<a name="coroutines.from_generators_to_coroutines"></a><h3>
<a name="id680954"></a>
        From generators to coroutines
      </h3>
<p>
        So far we have learned to use generators, a special kind of coroutines. We
        have seen that generators are function objects with no parameters and that
        return a sequence of values. We can generalize this concept to function objects
        that have zero, one or more parameters and return zero, one or more values.
        A generic coroutine is, not surprisingly, implemented with the <a href="../">coroutine</a>
        template class.
      </p>
<p>
        All examples in this sections will assume that the following using directive
        is in effect:
      </p>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">coroutine</span><span class="special">/</span><span class="identifier">coroutine</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<a name="coroutines.the_accumulator_coroutine"></a><h3>
<a name="id681017"></a>
        The accumulator coroutine
      </h3>
<p>
        Let's start with a very simple coroutine that takes as parameter an integer
        and returns the sum of that integer and all integers passed before. In practice
        it acts as an accumulator. As usual, we start by declaring its type:
      </p>
<pre class="programlisting">
<span class="keyword">typedef</span> <span class="identifier">coro</span><span class="special">::</span><a href="../">coroutine</a><span class="special">&lt;</span><span class="keyword">int</span><span class="special">(</span><span class="keyword">int</span><span class="special">)&gt;</span> <span class="identifier">coroutine_type</span><span class="special">;</span>
</pre>
<p>
        The syntax is deliberately similar to the one used in <a href="../link-to-boost-asio" target="_top">Boost.Function</a>.
        This is the coroutine body:
      </p>
<pre class="programlisting">
<span class="keyword">int</span> <span class="identifier">accumulator_body</span><span class="special">(</span><span class="identifier">coroutine_type</span><span class="special">::</span><a href="../">self</a><span class="special">&amp;</span> <span class="identifier">self</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">val</span><span class="special">)</span> <span class="special">{</span>
  <span class="keyword">while</span><span class="special">(</span><span class="keyword">true</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">val</span> <span class="special">+=</span> <span class="identifier">self</span><span class="special">.</span><a href="../">yield</a><span class="special">(</span><span class="identifier">val</span><span class="special">);</span>
  <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
        This is code is not very different from our first <a href="tutorial.html#generators.the_generator_class_template">generator
        example</a>. Still there are some differences. For example <tt class="computeroutput"><a href="../">yield</a><span class="special">()</span></tt>
        now returns a value. Soon we will see what this value represent. The syntax
        used to declare a coroutine is not surprising:
      </p>
<pre class="programlisting">
<span class="identifier">coroutine_type</span> <span class="identifier">accumulator</span><span class="special">(</span><span class="identifier">accumulator_body</span><span class="special">);</span> 
</pre>
<p>
        And even its usage is straight forward:
      </p>
<pre class="programlisting">
<span class="special">...</span>
<span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="number">1000</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">accumulator</span><span class="special">(</span><span class="identifier">i</span><span class="special">);</span>
<span class="special">...</span>
</pre>
<p>
        This will print all values in the mathematical series <tt class="computeroutput"><span class="identifier">a</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span>
        <span class="special">=</span> <span class="identifier">a</span><span class="special">[</span><span class="identifier">i</span><span class="special">-</span><span class="number">1</span><span class="special">]</span> <span class="special">+</span>
        <span class="identifier">i</span></tt>. Let's see how the flow control
        evolves.
      </p>
<div class="sidebar"><p>
        <span class="inlinemediaobject"><img src="../images/note.png" alt="note"></span> A <a href="../">coroutine</a>,
        unlike a <a href="../">generator</a>, will
        enter its body only when the <tt class="computeroutput"><a href="../">coroutine</a><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></tt> is invoked for the first time. This is
        because, generally, a coroutine requires parameters to be passed. In our
        example the parameter is the value to accumulate. <a href="../">generator</a>
        and <a href="../">coroutine</a> are intended
        for different use cases :generator functions and iterators the first, generalized
        control inversion the second. Their semantics are intended to be the most
        useful for each case.
      </p></div>
<div class="itemizedlist"><ul type="disc">
<li>
          The <tt class="computeroutput"><span class="keyword">for</span></tt> loop starts, <tt class="computeroutput"><span class="identifier">accumulator</span><span class="special">(</span><span class="number">0</span><span class="special">)</span></tt> is called.
        </li>
<li>
          The coroutine body is entered for the first time. The first statement of
          <tt class="computeroutput"><span class="identifier">accumulator_body</span></tt> is executed.
          At this point the parameter <tt class="computeroutput"><span class="identifier">val</span></tt>
          is <tt class="computeroutput"><span class="number">0</span></tt>.
        </li>
<li>
          The <tt class="computeroutput"><span class="keyword">while</span></tt> loop is entered
          and <tt class="computeroutput"><a href="../">yield</a><span class="special">(</span><span class="identifier">val</span><span class="special">)</span></tt> is invoked. The coroutine stops and relinquishes
          control to the main program, back in the <tt class="computeroutput"><span class="keyword">for</span></tt>
          loop.
        </li>
<li>
          At the next iteration, <tt class="computeroutput"><span class="identifier">accumulator</span><span class="special">(</span><span class="number">1</span><span class="special">)</span></tt>
          is called.
        </li>
<li>
          The coroutine is resumed at the point of the call to <tt class="computeroutput"><a href="../">coroutine</a><span class="special">::</span><a href="../">yield</a><span class="special">()</span></tt>, that returns the parameter passed to
          <tt class="computeroutput"><span class="identifier">accumulator</span></tt>, in this case
          <tt class="computeroutput"><span class="number">1</span></tt>.
        </li>
<li>
          The value returned by <tt class="computeroutput"><a href="../">yield</a><span class="special">()</span></tt> is added to <tt class="computeroutput"><span class="identifier">val</span></tt>
          and the coroutine continues to the next iteration, yielding <tt class="computeroutput"><span class="identifier">val</span></tt> again, now equal to <tt class="computeroutput"><span class="number">1</span></tt>.
        </li>
<li>
          At the next iteration of the <tt class="computeroutput"><span class="keyword">for</span></tt>
          loop <tt class="computeroutput"><span class="identifier">accumulator</span><span class="special">(</span><span class="number">2</span><span class="special">)</span></tt> is called
          and the coroutine will yield <tt class="computeroutput"><span class="number">3</span></tt>,
          the new value of <tt class="computeroutput"><span class="identifier">val</span></tt>.
        </li>
<li>
          ... and so on, until the end of the <tt class="computeroutput"><span class="keyword">for</span></tt>
          loop.
        </li>
</ul></div>
<p>
        When <tt class="computeroutput"><span class="identifier">accumulator</span></tt> goes out
        of scope, the coroutine is destroyed in the same way generators are destroyed:
        it is resumed and <a href="../">yield</a>()
        throws an instance of <tt class="computeroutput"><a href="../">exit_exception</a></tt>.
      </p>
<div class="sidebar"><p>
        <span class="inlinemediaobject"><img src="../images/caution.png" alt="caution"></span> Coroutines have the same limitation that generators
        <a href="stackful.html#recursive_generators">have</a>: a coroutine can never be
        recursive.
      </p></div>
<a name="coroutines.copyability"></a><h3>
<a name="id681778"></a>
        Copyability
      </h3>
<p>
        While you can freely copy a generator, you can't do the same with coroutines:
        during the development of Boost.Coroutine it has been deemed that giving
        reference counted shallow copying to coroutines was too risky. Coroutines
        usually have a longer lifetime and are more complex. Different coroutines
        can interact in dynamic ways, especially with the ability to yield to another
        coroutine (<tt class="computeroutput"><a href="../">yield_to</a><span class="special">()</span></tt> will be introduced in an <a href="symmetric_coroutines.html" title=" Symmetric coroutines">advanced
        section</a>).
      </p>
<p>
        The possibility of creating a cycle was very high and very hard to debug,
        thus the possibility of copying a <a href="../">coroutine</a>
        object has been removed. Coroutines instead are <a href="../">Movable</a>:
        you can return a coroutine from a function, copy construct and assign from
        a temporary, and explicitly <tt class="computeroutput"><span class="identifier">__move__</span><span class="special">()</span></tt> them, but you can't for example add them
        to a standard container, unless your standard library already has support
        for movable types (currently in the draft standard). A coroutine is also
        <a href="../">Swappable</a> and <a href="../">DefaultConstructible</a>.
      </p>
<p>
        Unfortunately most libraries expect copyable types and do not support moving.
        For interoperability with this libraries you should use a <tt class="computeroutput"><span class="identifier">shared_ptr</span></tt>
        to manage the lifetime of a <tt class="computeroutput"><a href="../">coroutine</a></tt>.
      </p>
<p>
        Boost.Coroutine also provides the <tt class="computeroutput"><a href="../">shared_coroutine</a></tt>
        that acts as a counted reference to a coroutine object. You should use this
        class template with care because potentially reopens the cycle loophole,
        and use it only as a temporary workaround for lack of movability.
      </p>
<a name="coroutines.exiting_a_coroutine_and_the__code__link_linkend__boost__coroutines__coroutine_exited__coroutine_exited__link___code__exception"></a><h3>
<a name="id681869"></a>
        Exiting a coroutine and the <tt class="computeroutput"><a href="../">coroutine_exited</a></tt>
        exception
      </h3>
<p>
        A coroutine can be exited from inside its body exactly like a generator by
        invoking <tt class="computeroutput"><a href="../">coroutine</a><span class="special">::</span><a href="../">self</a><span class="special">::</span><a href="../">exit</a><span class="special">()</span></tt>, but the semantics from the point of view
        of the caller are different. consider this piece of code that represent a
        call to the object <tt class="computeroutput"><span class="identifier">my_coroutine</span></tt>
        of type <tt class="computeroutput"><a href="../">coroutine</a><span class="special">&lt;</span><span class="keyword">int</span><span class="special">()&gt;()</span></tt>
      </p>
<pre class="programlisting">
<span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="identifier">my_coroutine</span><span class="special">();</span>
</pre>
<p>
        If <tt class="computeroutput"><span class="identifier">my_coroutine</span></tt> returns to
        the caller by invoking <tt class="computeroutput"><a href="../">exit</a><span class="special">()</span></tt>, there is no value can be returned from
        <tt class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></tt>
        and be assigned to <tt class="computeroutput"><span class="identifier">i</span></tt>. Instead
        a <tt class="computeroutput"><a href="../">coroutine_exited</a>
        <span class="identifier">exception</span> <span class="identifier">is</span>
        <span class="identifier">thrown</span> <span class="identifier">from</span>
        </tt>operator()`.
      </p>
<div class="sidebar"><p>
        <span class="inlinemediaobject"><img src="../images/note.png" alt="note"></span> Generators never throw <tt class="computeroutput"><a href="../">coroutine_exited</a></tt>
        because if a generator is valid it is always guaranteed that a value can
        be returned. We will see <a href="coroutines.html#coroutines.behind_generators">later</a>
        how this is possible.
      </p></div>
<p>
        A coroutine can also be exited by throwing any other exception from inside
        the body and letting the stack unwind below the coroutine main body. The
        coroutine is terminated and <tt class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></tt> will throw an instance of <tt class="computeroutput"><a href="../">abnormal_exit</a></tt>
        exception.
      </p>
<div class="sidebar"><p>
        <span class="inlinemediaobject"><img src="../images/note.png" alt="note"></span> Generators too may throw <tt class="computeroutput"><a href="../">abnormal_exit</a></tt>
        from <tt class="computeroutput"><span class="keyword">operator</span><span class="special">++</span></tt>
        or <tt class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></tt>.
      </p></div>
<p>
        Finally a coroutine can be exited from outside its body by calling <tt class="computeroutput"><a href="../">coroutine</a><span class="special">::</span><a href="../">exit</a><span class="special">()</span></tt>.
        It behaves exactly as if the coroutine had exited out of scope.
      </p>
<a name="coroutines.other_member_and_friend_functions"></a><h3>
<a name="id682163"></a>
        Other member and friend functions
      </h3>
<p>
        <tt class="computeroutput"><a href="../">coroutine</a></tt>
        provides a set of member functions to query its state; these are <tt class="computeroutput"><a href="../">exited</a><span class="special">()</span></tt>,
        <tt class="computeroutput"><a href="../">empty</a><span class="special">()</span></tt>, <tt class="computeroutput"><a href="../">waiting</a><span class="special">()</span></tt> and <tt class="computeroutput"><a href="../">pending</a><span class="special">()</span></tt>. <tt class="computeroutput"><a href="../">exited</a><span class="special">()</span></tt> returns true if a coroutine has been exited
        (by throwing an exception, by calling <tt class="computeroutput"><a href="../">exit</a><span class="special">()</span></tt> or by a plain return), <tt class="computeroutput"><a href="../">empty</a><span class="special">()</span></tt> returns true if a coroutine has not been
        assigned. <tt class="computeroutput"><a href="../">waiting</a><span class="special">()</span></tt> and <tt class="computeroutput"><a href="../">pending</a><span class="special">()</span></tt> are related to the event waiting mechanics
        and will be explained <a href="events.html" title=" Events">later</a>.
      </p>
<p>
        Both <tt class="computeroutput"><a href="../">coroutine</a><span class="special">::</span><a href="../">swap</a><span class="special">()</span></tt> and a friend <tt class="computeroutput"><a href="../">swap</a><span class="special">()</span></tt> are provided with the usual semantics.
      </p>
<p>
        <tt class="computeroutput"><a href="../">coroutine</a><span class="special">::</span><a href="../">self</a></tt>
        provides a <tt class="computeroutput"><a href="../">result</a><span class="special">()</span></tt> member function that returns the value
        returned by the last <tt class="computeroutput"><a href="../">yield</a><span class="special">()</span></tt> (or as a parameter to the body if <tt class="computeroutput"><a href="../">yield</a><span class="special">()</span></tt>
        has not been called yet).
      </p>
<p>
        The <tt class="computeroutput"><a href="../">coroutine</a><span class="special">::</span><a href="../">self</a><span class="special">::</span><a href="../">yield_to</a><span class="special">()</span></tt> member function will be explained in an
        advanced section about <a href="symmetric_coroutines.html" title=" Symmetric coroutines">symmetric
        coroutines</a>.
      </p>
<a name="coroutines.multiple_arguments_and_return_values"></a><h3>
<a name="id685175"></a>
        Multiple arguments and return values
      </h3>
<a name="accumulator_2"></a><p>
        A coroutine can have more than one argument. For example the coroutine <tt class="computeroutput"><span class="identifier">accumulator2</span></tt> is similar to <a href="coroutines.html#coroutines.the_accumulator_coroutine">accumulator</a>,
        but it takes two parameters and accumulate only the larger of the two values:
      </p>
<pre class="programlisting">
<span class="keyword">typedef</span> <span class="identifier">coro</span><span class="special">::</span><a href="../">coroutine</a><span class="special">&lt;</span><span class="keyword">int</span><span class="special">(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span><span class="special">)&gt;</span> <span class="identifier">coroutine_type</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">accumulator2_body</span><span class="special">(</span><span class="identifier">coroutine_type</span><span class="special">::</span><a href="../">self</a><span class="special">&amp;</span> <span class="identifier">self</span><span class="special">,</span>
                      <span class="keyword">int</span> <span class="identifier">arg1</span><span class="special">,</span>
                      <span class="keyword">int</span> <span class="identifier">arg2</span><span class="special">)</span> <span class="special">{</span>
  <span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
  <span class="keyword">while</span><span class="special">(</span><span class="keyword">true</span><span class="special">)</span> <span class="special">{</span>
     <span class="identifier">i</span> <span class="special">+=</span>  <span class="identifier">std</span><span class="special">::</span><span class="identifier">max</span><span class="special">(</span><span class="identifier">arg1</span><span class="special">,</span> <span class="identifier">arg2</span><span class="special">);</span>
     <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tie</span><span class="special">(</span><span class="identifier">arg1</span><span class="special">,</span> <span class="identifier">arg2</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">self</span><span class="special">.</span><a href="../">yield</a><span class="special">(</span><span class="identifier">i</span><span class="special">);</span>
  <span class="special">}</span>
<span class="special">}</span>

<span class="identifier">coroutine_type</span> <span class="identifier">accumulator2</span><span class="special">(</span><span class="identifier">accumulator2_body</span><span class="special">);</span>
</pre>
<p>
        Note that <a href="../">yield</a>
        now returns two values in the form of a <tt class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span>
        <span class="keyword">int</span><span class="special">&gt;</span></tt>.
        <tt class="computeroutput"><span class="identifier">accumulator2</span></tt> can be called
        like any other binary function or function object:
      </p>
<pre class="programlisting">
<span class="special">...</span>
<span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="identifier">accumulator2</span><span class="special">(</span><span class="number">0</span><span class="special">,</span> <span class="number">1</span><span class="special">);</span>
<span class="special">...</span>
</pre>
<a name="muladd"></a><p>
        Multiple return values are also handled with tuples. The coroutine <tt class="computeroutput"><span class="identifier">muladd</span></tt> returns the partial sum and the
        partial product of the argument passed so far:
      </p>
<pre class="programlisting">
<span class="keyword">typedef</span> <span class="identifier">coro</span><span class="special">::</span><a href="../">coroutine</a><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;(</span><span class="keyword">int</span><span class="special">)&gt;</span> <span class="identifier">coroutine_type</span><span class="special">;</span>

<span class="identifier">boost</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">muladd_body</span>
  <span class="special">(</span><span class="identifier">coroutine_type</span><span class="special">::</span><a href="../">self</a><span class="special">&amp;</span> <span class="identifier">self</span><span class="special">,</span> 
   <span class="keyword">int</span> <span class="identifier">val</span><span class="special">)</span> <span class="special">{</span>
  <span class="keyword">int</span> <span class="identifier">prod</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
  <span class="keyword">int</span> <span class="identifier">sum</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
  <span class="keyword">while</span><span class="special">(</span><span class="keyword">true</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">prod</span> <span class="special">+=</span> <span class="identifier">val</span><span class="special">;</span>
    <span class="identifier">sum</span>  <span class="special">+=</span> <span class="identifier">val</span><span class="special">;</span>
    <span class="identifier">val</span> <span class="special">=</span> <span class="identifier">self</span><span class="special">.</span><a href="../">yield</a><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_tuple</span><span class="special">(</span><span class="identifier">prod</span><span class="special">,</span> <span class="identifier">sum</span><span class="special">));</span>
  <span class="special">}</span>
<span class="special">}</span>

<span class="identifier">coroutine_type</span> <span class="identifier">muladd</span><span class="special">(</span><span class="identifier">muladd_body</span><span class="special">);</span>
</pre>
<p>
        Again, <tt class="computeroutput"><span class="identifier">muladd</span></tt> behaves like
        any other function that return a tuple:
      </p>
<pre class="programlisting">
<span class="special">...</span>
<span class="keyword">int</span> <span class="identifier">prod</span><span class="special">;</span>
<span class="keyword">int</span> <span class="identifier">sum</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">tie</span><span class="special">(</span><span class="identifier">prod</span><span class="special">,</span> <span class="identifier">sum</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">muladd</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>
<span class="special">...</span>
</pre>
<p>
        Notice that there is a slight asimmetry between <a href="coroutines.html#accumulator_2">the
        first</a> and <a href="coroutines.html#muladd">the second</a> example. In the
        call to <tt class="computeroutput"><span class="identifier">accumulator2</span></tt> there
        is no need to call <tt class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">make_tuple</span><span class="special">(...)</span></tt>, the arguments to <tt class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></tt> are automatically packed in the tuple that
        is returned by <tt class="computeroutput"><a href="../">yield</a><span class="special">()</span></tt>. On the other hand, in the call to <tt class="computeroutput"><a href="../">yield</a><span class="special">()</span></tt>
        in <tt class="computeroutput"><span class="identifier">muladd_body</span></tt>, the result
        types must manually packed in a tuple. It would be nice if this syntax could
        be used:
      </p>
<pre class="programlisting">
<span class="special">...</span>
<span class="identifier">self</span><span class="special">.</span><a href="../">yield</a><span class="special">(</span><span class="identifier">prod</span><span class="special">,</span> <span class="identifier">sum</span><span class="special">);</span>
<span class="special">...</span>
</pre>
<p>
        Boost.Coroutine in fact allows this user friendlier syntax, but it is not
        enabled by default because it could conflict with generic code. To enable
        it <tt class="computeroutput"><span class="identifier">coroutine_type</span></tt> must be
        redefined like this:
      </p>
<pre class="programlisting">
<span class="keyword">typedef</span> <span class="identifier">coro</span><span class="special">::</span><a href="../">coroutine</a><span class="special">&lt;</span><span class="identifier">coro</span><span class="special">::</span><span class="identifier">tuple_traits</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;(</span><span class="keyword">int</span><span class="special">)&gt;</span> <span class="identifier">coroutine_type</span><span class="special">;</span>
</pre>
<p>
        The <tt class="computeroutput"><a href="../">coroutine</a></tt>
        class template recognizes the special <tt class="computeroutput"><span class="identifier">coro</span><span class="special">::</span><span class="identifier">tuple_traits</span></tt>
        type and enables <tt class="computeroutput"><a href="../">yield</a><span class="special">()</span></tt> to automatically pack its arguments.
      </p>
<div class="sidebar"><p>
        <span class="inlinemediaobject"><img src="../images/note.png" alt="note"></span> <a href="../">coroutine</a>
        can handle any number of arguments and return values up to a implementation
        defined limit. The macro <tt class="computeroutput"><span class="identifier">BOOST_COROUTINE_ARG_MAX</span></tt>
        expands to the current limit. While it is technically possible to increase
        this number by redefining this macro, it also requires support for more arguments
        from other boost components (at least Boost.Tuple and Boost.MPL), thus this
        cap cannot be modified easily.
      </p></div>
<div class="sidebar"><p>
        <span class="inlinemediaobject"><img src="../images/caution.png" alt="caution"></span> Both <tt class="computeroutput"><a href="../">coroutine</a><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></tt> and <tt class="computeroutput"><a href="../">coroutine</a><span class="special">::</span><a href="../">yield</a></tt>
        can be called with a smaller amount of arguments than required by the <tt class="computeroutput"><a href="../">coroutine</a></tt> signature.
        The rightmost missing arguments are default constructed. This is an artifact
        of the current implementation, and at least in one instance has caused an
        hard to find bug. You shouldn't rely on this feature that will be probably
        removed from future versions of Boost.Coroutines. Finally note that non default
        constructible arguments cannot be omitted.
      </p></div>
<a name="coroutines.behind_generators"></a><h3>
<a name="id686398"></a>
        Behind generators
      </h3>
<p>
        To complete the tour of the basic capabilities of Boost.Coroutine we will
        return to the <a href="../">generator</a>
        class template and explain how it is implemented in term of coroutines. This
        is its definition:
      </p>
<pre class="programlisting">
<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ValueType</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">generator</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">iterator</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">input_iterator_tag</span><span class="special">,</span> <span class="identifier">ValueType</span><span class="special">&gt;</span> <span class="special">{</span>
  <span class="keyword">typedef</span> <span class="identifier">shared_coroutine</span><span class="special">&lt;</span><span class="identifier">ValueType</span><span class="special">()&gt;</span> <span class="identifier">coroutine_type</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">coroutine_type</span><span class="special">::</span><span class="identifier">result_type</span> <span class="identifier">value_type</span><span class="special">;</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">coroutine_type</span><span class="special">::</span><span class="identifier">self</span> <span class="identifier">self</span><span class="special">;</span>

  <span class="identifier">generator</span><span class="special">()</span> <span class="special">{}</span>

 <span class="identifier">generator</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">generator</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="special">:</span>
    <span class="identifier">m_coro</span><span class="special">(</span><span class="identifier">rhs</span><span class="special">.</span><span class="identifier">m_coro</span><span class="special">),</span>
    <span class="identifier">m_val</span><span class="special">(</span><span class="identifier">rhs</span><span class="special">.</span><span class="identifier">m_val</span><span class="special">)</span> <span class="special">{}</span>

  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Functor</span><span class="special">&gt;</span>
  <span class="identifier">generator</span><span class="special">(</span><span class="identifier">Functor</span> <span class="identifier">f</span><span class="special">)</span> <span class="special">:</span>
    <span class="identifier">m_coro</span><span class="special">(</span><span class="identifier">f</span><span class="special">),</span> 
    <span class="identifier">m_val</span><span class="special">(</span><span class="identifier">assing</span><span class="special">())</span> <span class="special">{}</span>

  <span class="identifier">value_type</span> <span class="keyword">operator</span><span class="special">*()</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="special">*</span><span class="identifier">m_val</span><span class="special">;</span>
  <span class="special">}</span>

  <span class="identifier">generator</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">++()</span> <span class="special">{</span>
    <span class="identifier">m_val</span> <span class="special">=</span> <span class="identifier">assing</span><span class="special">();</span>
  <span class="special">}</span>

  <span class="identifier">generator</span> <span class="keyword">operator</span><span class="special">++(</span><span class="keyword">int</span><span class="special">)</span> <span class="special">{</span>
     <span class="identifier">generator</span> <span class="identifier">t</span><span class="special">(*</span><span class="keyword">this</span><span class="special">);</span>
     <span class="special">++(*</span><span class="keyword">this</span><span class="special">);</span>
     <span class="keyword">return</span> <span class="identifier">t</span><span class="special">;</span>
  <span class="special">}</span>

  <span class="keyword">friend</span> <span class="keyword">operator</span><span class="special">==(</span><span class="keyword">const</span> <span class="identifier">generator</span><span class="special">&amp;</span> <span class="identifier">lhs</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">generator</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">lhs</span><span class="special">.</span><span class="identifier">m_val</span> <span class="special">==</span> <span class="identifier">rhs</span><span class="special">.</span><span class="identifier">m_val</span><span class="special">;</span>
  <span class="special">}</span>
<span class="keyword">private</span><span class="special">:</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">vale_type</span><span class="special">&gt;</span> <span class="identifier">assign</span><span class="special">()</span> <span class="special">{</span>
    <span class="keyword">try</span> <span class="special">{</span>
      <span class="keyword">return</span> <span class="identifier">m_coro</span><span class="special">?</span> <span class="identifier">m_coro</span><span class="special">()</span> <span class="special">:</span>  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">value_type</span><span class="special">&gt;();</span>
    <span class="special">}</span> <span class="keyword">catch</span> <span class="special">(</span><a href="../">coroutine_exited</a><span class="special">)</span> <span class="special">{</span>
      <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">value_type</span><span class="special">&gt;()</span>
    <span class="special">}</span>
  <span class="special">}</span>

  <span class="identifier">coroutine_type</span> <span class="identifier">m_coro</span><span class="special">;</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">value_type</span><span class="special">&gt;</span> <span class="identifier">m_val</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<div class="sidebar"><p>
        <span class="inlinemediaobject"><img src="../images/note.png" alt="note"></span> The code above is simplified for the sake of exposition.
        The actual <a href="../">generator</a>
        class template is a bit more complex: it handles correctly <tt class="computeroutput"><span class="keyword">void</span></tt> result types and <tt class="computeroutput"><span class="identifier">tuple_traits</span></tt>,
        it has an <tt class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></tt>,
        a <tt class="computeroutput"><span class="identifier">safe</span><span class="special">-</span><span class="keyword">bool</span></tt> conversion and a friend <tt class="computeroutput"><span class="keyword">operator</span> <span class="special">!=</span></tt>
      </p></div>
<p>
        <a href="../">generator</a> has two members
        variables:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
<tt class="computeroutput"><span class="identifier">m_coro</span></tt> of type <tt class="computeroutput"><span class="identifier">shared_coroutine</span><span class="special">&lt;</span><span class="identifier">value_type</span><span class="special">()&gt;</span></tt>
          is the coroutine in term of which <tt class="computeroutput"><a href="../">generator</a></tt>
          is implemented.
        </li>
<li>
<tt class="computeroutput"><span class="identifier">m_val</span></tt> of type <tt class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">value_type</span><span class="special">&gt;</span></tt>
          is the next value that will be returned by <tt class="computeroutput"><span class="keyword">operator</span><span class="special">*</span></tt>. An empty optional represent a past-the-end
          iterator.
        </li>
</ul></div>
<p>
        The first two member functions are the default constructor and the copy constructor.
        There is nothing peculiar in them. Note how a default constructed <tt class="computeroutput"><a href="../">generator</a></tt> has an empty
        <tt class="computeroutput"><span class="identifier">m_val</span></tt> and thus is a past-the-end
        iterator.
      </p>
<p>
        The third member constructs the generator from a function or function object
        parameter. The argument is forwarded to the <tt class="computeroutput"><span class="identifier">m_coro</span></tt>
        member to initialize the internal coroutine. <tt class="computeroutput"><span class="identifier">m_val</span></tt>
        is then initialized by a call to <tt class="computeroutput"><span class="identifier">assing</span><span class="special">()</span></tt>.
      </p>
<p>
        <tt class="computeroutput"><span class="keyword">operator</span><span class="special">*</span></tt>
        simply returns <tt class="computeroutput"><span class="special">*</span><span class="identifier">m_val</span></tt>,
        that is the current value stored in the optional. The result of dereferencing
        a past-the-end iterator is undefined.
      </p>
<p>
        The prefix <tt class="computeroutput"><span class="keyword">operator</span><span class="special">++</span></tt>
        simply reassign the result of <tt class="computeroutput"><span class="identifier">assign</span><span class="special">()</span></tt> to <tt class="computeroutput"><span class="identifier">m_val</span></tt>.
      </p>
<p>
        The postfix <tt class="computeroutput"><span class="keyword">operator</span><span class="special">++</span></tt>
        is implemented in terms of the prefix <tt class="computeroutput"><span class="keyword">operator</span><span class="special">++</span></tt> in the usual way.
      </p>
<p>
        <tt class="computeroutput"><span class="keyword">operator</span><span class="special">==</span></tt>
        compares two generators for equality by comparing their <tt class="computeroutput"><span class="identifier">m_val</span></tt>
        members. Notice that two past-the-end iterators have both empty <tt class="computeroutput"><span class="identifier">m_val</span></tt> and compare equally.
      </p>
<p>
        <tt class="computeroutput"><span class="identifier">assign</span><span class="special">()</span></tt>
        is responsible of returning the next value in the sequence by invoking the
        underlying coroutine and eventually signaling the end of iteration. It first
        checks the coroutine for liveness (through <a href="../">coroutine</a>
        <tt class="computeroutput"><span class="identifier">safe</span><span class="special">-</span><span class="keyword">bool</span></tt> conversion). If the coroutine is live
        it returns the result of a call to the coroutine. If the coroutine is dead
        (it has exited or has never been initialized) it returns an empty optional.
        Notice that the call to the coroutine could throw a <tt class="computeroutput"><span class="identifier">coroutine_exited</span></tt>
        exception if the coroutine exited, without yielding a value, by invoking
        <tt class="computeroutput"><a href="../">exit</a><span class="special">()</span></tt>. In that case an empty optional is returned.
      </p>
<p>
        The <tt class="computeroutput"><span class="keyword">try</span> <span class="special">{...}</span>
        <span class="keyword">catch</span><span class="special">(</span><a href="../">coroutine_exited</a><span class="special">)</span> <span class="special">{...}</span></tt> idiom
        is frequent in code that use coroutines that are expected to terminate via
        <tt class="computeroutput"><a href="../">exit</a><span class="special">()</span></tt> (that this, the <tt class="computeroutput"><a href="../">exit</a><span class="special">()</span></tt> termination path is not "exceptional").
        Boost.Coroutine provides a way to simplify this code by completely eliminating
        the exception. For example <tt class="computeroutput"><span class="identifier">assign</span><span class="special">()</span></tt> can be rewritten as:
      </p>
<pre class="programlisting">
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">vale_type</span><span class="special">&gt;</span> <span class="identifier">assing</span><span class="special">()</span> <span class="special">{</span>
  <span class="keyword">return</span> <span class="identifier">m_coro</span><span class="special">?</span> <span class="identifier">m_coro</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">nothrow</span><span class="special">)</span> <span class="special">:</span>  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">value_type</span><span class="special">&gt;();</span>
<span class="special">}</span>
</pre>
<p>
        Notice the extra <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">nothrow</span></tt> parameter. If the first parameter
        to a <tt class="computeroutput"><a href="../">coroutine</a><span class="special">&lt;</span><span class="identifier">result_type</span><span class="special">(...)&gt;::</span><span class="keyword">operator</span><span class="special">()</span></tt> is an object of type <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">nothrow_t</span></tt>,
        the return type of the operator is modified to <tt class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">result_type</span><span class="special">&gt;</span></tt>. The optional will contain the normal
        result value in the case of a normal <tt class="computeroutput"><span class="identifier">yield</span><span class="special">()</span></tt> or <tt class="computeroutput"><span class="keyword">return</span></tt>
        statement, or will be empty if the coroutine has been exited via <tt class="computeroutput"><a href="../">exit</a><span class="special">()</span></tt>.
        Notice that if <tt class="computeroutput"><span class="identifier">result_type</span></tt>
        was <tt class="computeroutput"><span class="keyword">void</span></tt> it will remain unchanged
        (no optional will be returned), but no exception will be thrown.
      </p>
<p>
        If the coroutine terminates because of an uncaught exception not of type
        <tt class="computeroutput"><a href="../">exit_exception</a></tt>,
        <tt class="computeroutput"><span class="keyword">operator</span><span class="special">()(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">nothrow</span><span class="special">)</span></tt> will still throw an <tt class="computeroutput"><a href="../">abnormal_exit</a></tt>
        exception.
      </p>
<p>
        If a coroutine takes one or more parameters, std::nothrow must be the first
        parameter. For example a coroutine <tt class="computeroutput"><span class="identifier">my_coro</span></tt>
        of type:
      </p>
<pre class="programlisting">
<span class="keyword">typedef</span> <span class="identifier">coro</span><span class="special">::</span><span class="identifier">coroutine</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">(</span><span class="keyword">long</span><span class="special">,</span> <span class="keyword">double</span><span class="special">,</span> <span class="keyword">char</span><span class="special">)&gt;</span> <span class="identifier">coroutine_type</span><span class="special">;</span>
</pre>
<p>
        Will be invoked like this:
      </p>
<pre class="programlisting">
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">res</span> <span class="special">=</span> <span class="identifier">my_coro</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">nothrow</span><span class="special">,</span> <span class="number">10000L</span><span class="special">,</span> <span class="number">10.7</span><span class="special">,</span> <span class="char">'a'</span><span class="special">);</span>
</pre>
<a name="producer_consumer2"></a><p>
      </p>
<a name="coroutines.example__producer_consumer_revisited"></a><h3>
<a name="id688162"></a>
        Example: producer/consumer revisited
      </h3>
<p>
        A <a href="producer_consumer1.html" title=" Example: the producer/consumer pattern">previous example</a> presented
        a consumer driven version of the <span class="emphasis"><em>producer/consumer</em></span> pattern.
        We will now implement a producer driven example of the same scenario:
      </p>
<pre class="programlisting">
<span class="keyword">typedef</span> <span class="identifier">coroutine</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;)&gt;</span> <span class="identifier">coroutine_type</span><span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Consumer</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">producer</span><span class="special">(</span><span class="identifier">Consumer</span> <span class="identifier">consumer</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">base</span><span class="special">)</span> <span class="special">{</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">sort</span><span class="special">(</span><span class="identifier">base</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">base</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span>
  <span class="keyword">do</span> <span class="special">{</span>
    <span class="identifier">consumer</span><span class="special">(</span><span class="identifier">base</span><span class="special">);</span>
  <span class="special">}</span> <span class="keyword">while</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">next_permutation</span><span class="special">(</span><span class="identifier">base</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">base</span><span class="special">.</span><span class="identifier">end</span><span class="special">()));</span>
<span class="special">}</span>

<span class="keyword">void</span> <span class="identifier">consumer</span><span class="special">(</span><span class="identifier">coroutine_type</span><span class="special">::</span><span class="identifier">self</span><span class="special">&amp;</span> <span class="identifier">self</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">)</span> <span class="special">{</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">value</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
  <span class="keyword">while</span><span class="special">(</span><span class="keyword">true</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">self</span><span class="special">.</span><span class="identifier">yield</span><span class="special">()&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
  <span class="special">}</span> 
<span class="special">}</span>
</pre>
<div class="sidebar"><p>
        <span class="inlinemediaobject"><img src="../images/note.png" alt="note"></span> <a href="../">coroutine</a>
        too correctly handles reference types. This specific example doesn't have
        the reference lifetimes issues the <a href="producer_consumer1.html" title=" Example: the producer/consumer pattern">previous</a>
        had, but coroutines aren't in general immune to them.
      </p></div>
<p>
        Here we take advantage of the capability to pass arguments in a coroutine
        invocation to reverse the leading role of the pattern. Extending this pattern
        to support filter functions is left as an exercise for the reader.
      </p>
<a name="coroutines.conclusions"></a><h3>
<a name="id688652"></a>
        Conclusions
      </h3>
<p>
        We have now terminated our tour on the basic capabilities of <tt class="computeroutput"><a href="../">coroutine</a></tt> and <tt class="computeroutput"><a href="../">generator</a></tt>. The next
        section will describe more advanced features, including symmetric coroutines
        and event handling.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2006 Giovanni P. Deretta<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">
        http://www.boost.org/LICENSE_1_0.txt </a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="stackful.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="tutorial.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="multitasking.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
